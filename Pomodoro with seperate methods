//Need to make a function that stops the timer if the button is pressed again or remove the button all together. 
//Also need to finish the function so when breaktime is finished reset back to normal. Can add a variable equal to true 
//Timer is still off, may need to round a certain way?
//Instead of getting current time and time plus amount of minutes, why not just set variable equal to # of minutes in milliseconds and subtract 1000 every second?
//Instead of having timer function, just put function within the setInterval using workTime first and breakTime second. Won't allow me to use "workTime" and "breakTime" as variables in timer(time). Always starts timer(time) with the original value of workTime or breakTime instead of subtracting it...

//https://www.w3schools.com/jsref/met_win_cleartimeout.asp

var minutes;
var seconds;
var workTime;
var breakTime;
var countDown;
var timer;

  
  
//When button pressed, retrieve values of each timer and start the timer countdown with workTime until finished, then breakTime.

$('#timer').click(function(){
  console.log('Button pressed');  
  if (timer == true){
    timer = false;
    console.log('stopping timer, timer = false');
    stopTimer();
    return;
  }
  //Think about using recursion? 
  //function count(){
  //workTime -= 1000
  //countDown = setTimeout(function(){count},1000);
  //execute once with setTimeout, use recursion to call itself?
  
  workTime = (document.getElementById('work').value) * (60 * 1000);
  breakTime = (document.getElementById('break').value) * (60 * 1000);
  
  timerFunc();
});

function timerFunc(){
  //Track if timer is currently running or not. 
  console.log('timerFunc starting');
  
  if (!timer){
    console.log('timer will be true');
    timer = true;    
  }
  
  console.log('workTime:', workTime, 'breakTime:', breakTime);
  
  if (workTime > 0){
    workTime -= 1000;
    
    minutes = Math.floor((workTime % (1000*60*60)) / (1000*60));
    seconds = Math.floor ((workTime % (1000*60)) / 1000);
    document.getElementById('demo').innerHTML = minutes + ":" + seconds;
  }
  
  else{
    breakTime -= 1000;
    minutes = Math.floor((breakTime % (1000*60*60)) / (1000*60));
    seconds = Math.floor ((breakTime % (1000*60)) / 1000);
    document.getElementById('demo').innerHTML = minutes + ":" + seconds;
  }
  
  
  countDown = setTimeout(function(){timerFunc()},1000);
  
  
};

function stopTimer(){
  clearInterval(countDown);
}



//Need to check timers and see if the negative numbers still come up when coming back from pausing break, and why?

